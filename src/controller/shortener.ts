import { RequestHandler } from "express";
import { Record } from '../model/record'
import { shortener } from "../utils/shortener";

import { urlTable, userTable } from '../utils/bigTableClient';
import { UserDecoded } from "../model/user";
import redisClient from '../utils/redisClient';

import jwt_decode from "jwt-decode";
import { updateCountryCount } from "../utils/country";
import { updateURLStats } from "../utils/stats";

import { NestedObj } from "../model/bulk";

export const redirectURL: RequestHandler = async(req, res, next) => {
    const shortURL = req.params.shortURL;

    // ------------------------------------------
    try{
        const [rowExists] = await urlTable.row(shortURL).exists();

        // If short URL does not exist in database
        if (!rowExists) {
            res.render('error');
            res.status(404);
            return;
        }

        const [singleRow] = await urlTable.row(shortURL).get();
        const record = singleRow.data;
        
        // If the longURL is expired
        if (!('longURL' in record.info)) {
            res.render('error');
            res.status(404);
            return;
        }
        
        // Count the country requests
        await updateURLStats(req, shortURL);

        
        // If the shortURL belongs to a user, then do not go to refer page
        if (('level' in record.info) && parseInt(record.info.level[0].value) >= 1) {

            // Set refer to false, so the cache handler know NOT to go to refer page
            record.refer = false;
            
            // We store to redis, cause we DO NOT need to go to refer page first 
            // Set expired time to be 60 seconds
            await redisClient.setEx(shortURL, 60, JSON.stringify(record));

            res.status(302).redirect("https://" + record.info.longURL[0].value);
        }

        else {
            // Set refer to false, so the cache handler know NOT to go to refer page
            record.refer = true;
            await redisClient.setEx(shortURL, 60, JSON.stringify(record));

            res.render("refer", record.info.longURL[0]);
        }


        // res.status(302).redirect("https://" + record.info.longURL[0].value);

    }
    catch(err){
        console.log(err);
        next(err);
        //res.status(500).send({message: "Internal Server Error"});
    }

}

export const getCache: RequestHandler = async(req, res, next) => {
    const shortURL = req.params.shortURL;

    const result = await redisClient.get(shortURL); // This return a string

    if (result !== null){
        const record: Record = JSON.parse(result);
        
        // Count the country requests
        await updateURLStats(req, shortURL);

        // Check if this short URL need to go Refer page
        if (!record.refer){
            res.status(302).redirect("https://" + record.info.longURL[0].value);
        }

        else{
            res.render("refer", record.info.longURL[0]);
        }
        
    }
    else {
        next();
    }
}


export const shortenURL: RequestHandler = async(req, res) => {
    let longURL = req.body.longURL;
    const timestamp = new Date();

    // Check if the user is logged in
    const userExists = (req.body.credential !== undefined);

    // Create empty variables to store the data ready to be stored in DBs
    let userTableToInsert = undefined;
    let rowToInsert = undefined;

    // Remove the protocol
    longURL = longURL.replace(/(^\w+:|^)\/\//, '');
    let shortURL = shortener(longURL);

    // Check if the shortURL is generated by a login user
    if (userExists){
        const decoded: UserDecoded = jwt_decode(req.body.credential);
        const userLevel: string = req.body.userLevel;
        
        userTableToInsert = {
            'key': decoded.email,
            'data': {
                'url': { // column family
                    [shortURL]: {
                        value: longURL,
                        timestamp: timestamp
                    },
                } 
            }
        }

        rowToInsert = {
            key: shortURL,
            data: {
                info: {  // column family
                    longURL: {
                        value: longURL,
                        timestamp: timestamp,
                    },
                    level: { // Used to identify user level, so that can decided if we redirect to refer page 
                        value: userLevel,
                        timestamp: timestamp
                    }
                }
            },
        };

    }

    else{
        rowToInsert = {
            key: shortURL,
            data: {
                info: {  // column family
                    longURL: {
                        value: longURL,
                        timestamp: timestamp,
                    },
                    level: { // Used to identify user level, so that can decided if we redirect to refer page 
                        value: -1, // Means the url is not belonged to the user
                        timestamp: timestamp
                    }
                }
            },
        };
    }

    
    try {
        await urlTable.insert(rowToInsert);

        if(userExists){
            await userTable.insert(userTableToInsert);
        }

        res.status(200).send({"shortURL": shortURL});
    }
    catch(err){
        console.log(err);
        res.status(500).send({message: "Internal Server Error"});
    }
}

export const createAlias: RequestHandler = async(req, res) => { 
    const alias = req.body.alias;
    const decoded: UserDecoded = jwt_decode(req.body.credential);
    const userLevel: string = req.body.userLevel;
    let longURL = req.body.longURL;
    

    const timestamp = new Date();
    timestamp.setFullYear(timestamp.getFullYear() + 10);

    longURL = longURL.replace(/(^\w+:|^)\/\//, '');

    const urlTableToInsert = {
        key: alias,
        data: {
            info: {  // column family
                longURL: {
                    value: longURL,
                    timestamp: timestamp,
                },
                level: { // Used to identify user level, so that can decided if we redirect to refer page 
                    value: userLevel,
                    timestamp: timestamp
                }
            }
        },
    };

    const userTableToInsert = {
        'key': decoded.email,
        'data': {
            'url': { // column family
                [alias]: {
                    value: longURL,
                    timestamp: timestamp
                },
            } 
        }
    }

    try {
        await urlTable.insert(urlTableToInsert);
        await userTable.insert(userTableToInsert);
        res.status(200).send({"shortURL": alias});
    }
    catch(err){
        console.log(err);
        res.status(500).send({message: "Internal Server Error"});
    }
}


export const deleteURL: RequestHandler = async(req, res) => {
    const shortURL = req.params.shortURL;


    try{
        await urlTable.row(shortURL).deleteCells(["info:longURL"]);

        res.status(200).send({message: "Short url deleted successfully"});

    }
    catch(err){
        console.log(err);
        res.status(500).send({message: "Internal Server Error"});
    }
}


export const bulkShortenURL: RequestHandler = async(req, res) => {
    const bulkLongURL = req.body.longURLs;
    const timestamp = new Date();

    // Check if the user is logged in
    const userExists = (req.body.credential !== undefined);

    // Create empty variables to store the data ready to be stored in DBs
    let userTableToInsert: NestedObj = {};
    let rowsToInsert: NestedObj[] = [];

    // Remove the protocol
    let longURLs: string[] = bulkLongURL.split('\n');
    longURLs = longURLs.map((url: string) => url.replace(/(^\w+:|^)\/\//, ''));

    // Get shortURLs
    const shortURLs: string[] = longURLs.map((url: string) => shortener(url));


    // Check if the shortURLs are generated by a login user
    if (userExists){
        const decoded: UserDecoded = jwt_decode(req.body.credential);
        const userLevel: string = req.body.userLevel;
        
        let urlsToInsert: NestedObj = {}

        for(let i = 0; i < shortURLs.length; i++){
            urlsToInsert[shortURLs[i]] = { value: longURLs[i], timestamp: timestamp }
        }

        userTableToInsert = {
            'key': decoded.email,
            'data': {
                'url': urlsToInsert
            }
        }


        rowsToInsert = shortURLs.map((shortURL, idx) => ({
            key: shortURL,
            data: {
                info: {
                    longURL: {
                        value: longURLs[idx],
                        timestamp: timestamp,
                    },
                    level: {
                        value: userLevel,
                        timestamp: timestamp
                    }
                }
            },
        }))

    }

    else{
        rowsToInsert = shortURLs.map((shortURL, idx) => ({
            key: shortURL,
            data: {
                info: {
                    longURL: {
                        value: longURLs[idx],
                        timestamp: timestamp,
                    },
                    level: {
                        value: -1,
                        timestamp: timestamp
                    }
                },
            },
        }))
    }


    try {
        await urlTable.insert(rowsToInsert);

        if(userExists){
            await userTable.insert(userTableToInsert);
        }

        res.status(200).send({"shortURLs": shortURLs.join('\n')});
    }
    catch(err){
        console.log(err);
        res.status(500).send({message: "Internal Server Error"});
    }
}